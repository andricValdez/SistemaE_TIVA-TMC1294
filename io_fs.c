//*****************************************************************************
//
// io_fs.c - File System Processing for enet_io application.
//
// Copyright (c) 2007-2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
// Texas Instruments (TI) is supplying this software for use solely and
// exclusively on TI's microcontroller products. The software is owned by
// TI and/or its suppliers, and is protected under applicable copyright
// laws. You may not combine this software with "viral" open-source
// software in order to form a larger program.
// 
// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
// DAMAGES, FOR ANY REASON WHATSOEVER.
// 
// This is part of revision 2.1.0.12573 of the EK-TM4C1294XL Firmware Package.
//
//*****************************************************************************

//*****************************************************************************
//
// Include the web file system data for this application.  This file is
// generated by the makefsfile utility, using the following command:
//
//     ../../../../tools/bin/makefsfile -i fs -o io_fsdata.h -r -h -q
//
// If any changes are made to the static content of the web pages served by the
// application, this script must be used to regenerate io_fsdata.h in order
// for those changes to be picked up by the web server.
//
//*****************************************************************************

#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_ints.h"

#include "driverlib/ssi.h"
#include "driverlib/flash.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/sysctl.h"
#include "driverlib/watchdog.h"
#include "driverlib/systick.h"
#include "driverlib/timer.h"
#include "driverlib/rom_map.h"
#include "driverlib/rom.h"
#include "driverlib/pin_map.h"
#include "driverlib/uart.h"

#include "utils/lwiplib.h"
#include "utils/ustdlib.h"
#include "utils/uartstdio.h"
#include "httpserver_raw/httpd.h"
#include "httpserver_raw/fs.h"
#include "httpserver_raw/fsdata.h"
#include "drivers/pinout.h"
#include "io.h"



//************************************************************************************************************
//                       EJEMPLO DE COMANDOS DE CONTROL Y RESPUESTA EN HEX, PARA PROYECTORES NEC
//************************************************************************************************************
//
//***** Power ON
//          Command            --> 0x02, 0x00, 0x00, 0x00, 0x00, 0x02
//          Response (Success) --> 0x22, 0x00, ID1,  ID2,  0x00, CKS
//          Response (Fail)    --> 0xA2, 0x00, ID1,  ID2,  0x02, ERR1, ERR2, CKS
//
//***** Power OFF
//          Command            --> 0x02, 0x01, 0x00, 0x00, 0x00, 0x03
//          Response (Success) --> 0x22, 0x01, ID1,  ID2,  0x00, CKS
//          Response (Fail)    --> 0xA2, 0x01, ID1,  ID2,  0x02, ERR1, ERR2, CKS
//
//***** Running status Request
//          Command            --> 0x00, 0x85, 0x00, 0x00, 0x01, 0x01, 0x87
//          Response (Success) --> 0x20, 0x85, ID1,  ID2,  0x10, <DATA01>-<DATA16>, CKS
//          Response (Fail)    --> 0xA0, 0x85, ID1,  ID2,  0x02, ERR1, ERR2, CKS
//
//
//***** Nota:
// ID1    --> Este es un ID del proyector que trae de fábrica
// ID2    --> Este es un código para cada modelo de la marca NEC (E.g. para el modelo UM330 --> 0x70)
// ERR1   --> Tipo de error
// ERR2   --> Descripción del error
//
//***** Para Response (Success) de Running status Request:
// DATA03 --> Power Status,        con valor 0x01 --> Power ON
// DATA05 --> Power ON/OFF Prcess, con valor 0x00 --> No ejecución, con valor 0x01 --> Durante Ejecución
// DATA06 --> Operation Status,    con valor 0x04 --> Power ON
//
//************************************************************************************************************

//**************************************************************************
//                          DECLARACIÓN DE VARIABLES EXTERNAS
//**************************************************************************

extern uint32_t g_ui32SysClock; //Frecuencia de reloj del sistema, declarada en enet_io



//**************************************************************************
//                          DECLARACIÓN DE MACROS
//**************************************************************************

#define FIFOSIZE            50  //Tamaño de FIFO para almacenar datos de respuesta (Ack) del proyector
#define CMDCONTROLSIZE      50  //Tamaño de onCmdHex para almacenar los comandos en Hex envíados por el usuario a través de la URL



//**************************************************************************
//                         DECLARACIÓN DE FUNCIONES
//**************************************************************************

void initFifo(void);
int PutFifo(unsigned char data);
int GetFifo(unsigned char *datapt);
char checkProjectorResponse(void);
unsigned long getParamURL(char *pcBuf);



//**************************************************************************
//                     DECLARACIÓN DE VARIABLES GLOBALES
//**************************************************************************

uint32_t Flag = 0;
int numberCmd;                            //Variable con el número de comandos en Hex almacenados en el arreglo onCmdHex[]
int numberCmdAck;                         //Variable con el número de comandos en Hex almacenados en el arreglo ackCmdHex[]
unsigned char *PUTPT;                     //Puntero que apunta a donde pondrá el dato
unsigned char *GETPT;                     //Puntero que apunta a donde tomará el dato
unsigned char  FIFO[FIFOSIZE];            //Datos del FIFO almacenados estaticamente << FIFO Consumer >>
unsigned char  onCmdHex[CMDCONTROLSIZE];  //Arreglo para almacenar comandos en Hex enviados a los proyectores
unsigned char  ackCmdHex[CMDCONTROLSIZE]; //Arreglo para almacenar comandos en Hex enviados por los proyectores (respuesta del proyector)
unsigned long  delayToWaitResopnseProj = 3000000; //Tiempo de espera del uC a la respuesta (Ack) de los proyectores a los cmd enviados


//**************************************************************************
//                               FUNCIONES
//**************************************************************************

unsigned long getParamURL(char *pcBuf){

    //*** Declaración de variables ***
    int  cnt, i, j, cntEqual;
    char *p, *p2;

    // Arreglo donde se almacena momentaneamente los parámetro tomados de la URL
    char auxCmd[CMDCONTROLSIZE]; 
    
    // uv, uv2, baudRate son variables donde se almacena la conversión de tipo de dato
    unsigned char uv  = 0;       
    unsigned char uv2 = 0;
    unsigned long baudRate;

    // Variables booleanas usadas para el control de acceso a los parametros de la URL
    bool auxCmdhex   = false;    
    bool auxCmdhex2  = true;
    bool auxBaudrate = false;
    bool auxCmdAck   = false;
    bool auxCmdAck2  = false;

    // Limpiar buffer de almacenamiento de comandos
    for(i=0; i<CMDCONTROLSIZE; i++) 
        onCmdHex[i] = 0;

    // Inicializar variables numéricas en cero
    cnt          = 0;  
    cntEqual     = 0;
    numberCmd    = 0;
    numberCmdAck = 0;

    // Continua tomando caracter por caracter de la URL hasta encontrar el caracter de terminación nulo
    while(*(pcBuf++) != '\0'){  

        // Almacena el caracter actual tomado de la URL en auxCmd[]
        auxCmd[cnt] = *(pcBuf); 

        auxCmdhex   = false;
        auxBaudrate = false;
        auxCmdAck2  = false;

        //Las siguientes sentencias condicinales toman los parámetros de la URL y los convierten al tipo de dato correspondiente
        //Datos a extraer de la URL:
        //onCmdHex[] ---> Almacena comandos de control en Hex para enviarlos al proyector
        //ackCmdHex[] --> Almacena comandos de respuesta en Hex enviados por el proyector (acknowledge)
        //baudRate -----> Almacena el baudRate que el usuario envió mediante la URL
        if(*(pcBuf) == '='){
            auxBaudrate = true;
            cntEqual++;
        }

        if(cntEqual == 2){
            auxCmdAck  = true;
            auxCmdAck2 = true;
            cntEqual++;
            for(j=0; j<CMDCONTROLSIZE; j++)
                auxCmd[j] = 0;
        }

        if((cnt == 1) && (auxCmdhex2)){
            uv = strtoul(auxCmd, &p, 16);
            onCmdHex[numberCmd] = uv;
            numberCmd++;
            auxCmdhex = true;
        }

        if((cnt == 1) && (auxCmdAck)){
            uv2 = strtoul(auxCmd, &p2, 16);
            ackCmdHex[numberCmdAck] = uv2;
            numberCmdAck++;
            auxCmdAck2 = true;
        }

        cnt++;

        if(auxCmdhex)
            cnt = 0;

        if(auxCmdAck2)
            cnt = 0;

        if((*(pcBuf) == '&') || (*(pcBuf) == '*')){
            auxCmdhex2 = false;
            auxCmdAck  = false;
        }

        if((auxBaudrate) && (cntEqual<2))
            cnt = 0;

        if(*(pcBuf) == '+'){
            auxCmd[cnt] = 0;
            baudRate = strtoul(auxCmd, &p2, 10);
        }
    }
    return baudRate;
}

void initFifo(void){

    /*FIFO está vacío si PUTPT = GETPT
    FIFO está lleno si PUTPT+1 = GETPT*/
    PUTPT=GETPT=&FIFO[0]; 
}

int PutFifo(unsigned char data){

    // Puntero PUT temporal
    unsigned char *Ppt; 
    // Copia del puntero put, ambos apuntan en un principio a FIFO[0]
    Ppt = PUTPT;     
    // Poner datos en FIFO, asigna dato al elemento de FIFO actual y despues apunta al siguiente
    *(Ppt++) = data; 

    // Si el puntero apunta a una dirección de memoria más que FIFOSIZE
    if (Ppt == &FIFO[FIFOSIZE]) 
        // Hemos llegado al final del FIFO, regrasamos a la posición FIFO[0]
        Ppt = &FIFO[0];         
    // si PUTPT+1 = GETPT
    if (Ppt == GETPT)   
        // Error, FIFO lleno
        return (0);     
    // Success y actualizamos PUTPT
    else{
        PUTPT = Ppt;    
        return(-1);
    }
}

int GetFifo(unsigned char *datapt){

    // Estamos al principio de FIFO ?? Esto es que FIFO está vacío (no hay datos para consumir)
    if (PUTPT == GETPT)
        return(0);  

    else{
        // Al dato que apunta GETPT se lo asignamos a datapt y despues sumamos 1 a GETPT
        *datapt = *(GETPT++);  
        // Se llego al final de FIFO ??
        if (GETPT == &FIFO[FIFOSIZE]) 
            // Regresamos al principio de FIFO
            GETPT = &FIFO[0]; 
        return (-1); //Sucsess
    }
}


char checkProjectorResponse(void) {

    // Declaración de variables
    unsigned long NumElement;
    unsigned char GetResponseFIFO[FIFOSIZE];
    unsigned char ResponseType, i, j, cntCmdSuccess;

    // Numeros de elementos en la respuesta Ack del proyector
    NumElement    = 0;              
    cntCmdSuccess = 0;

    // Limpiamos Buffer de almacenamiento de respuesta tomada de FIFO
    for(i=0; i<FIFOSIZE; i++)    
        GetResponseFIFO[i] = 0;
    // Loop for para consumo de datos de FIFO
    for(j=0; j<FIFOSIZE; j++){
        // Hay todavía datos para consumir? return -1 cuando hay datos para consumir, return 0 cuando no
        if (GetFifo(&GetResponseFIFO[j]))
            NumElement++;
        //Si ya no hay datos en el FIFO para consumir, salimos del loop
        else                     
            break;
    }
    // Error: No hay conexión entre Proyector-uC o no hubo respuesta del proyector al comando de control enviado
    if(NumElement == 0)
        ResponseType = '2';  
    else{
        // Mandar por uart0 Tx respuesta enviada por el proyector (solo para fines de pruebas)
        for(i=0; i<NumElement; i++)
            UARTCharPut(UART0_BASE, GetResponseFIFO[i]);
        // Checar si los comandos devueltos por el proyector (Ack) coinciden con los que el usuario indicó
        for(i=0; i<numberCmdAck; i++){
            if(GetResponseFIFO[i] == ackCmdHex[i])
                cntCmdSuccess++;
        }
        // Los comandos de respuesta de proyector son correctos? 
        if(cntCmdSuccess == numberCmdAck)
            //un '1' representa que el comando envíado al proyector realizó la opeación/acción deseada
            ResponseType = '1';  
        else
            //Error al enviar el comando - la respuesta del proyector no es la misma que el usuario indicó -
            ResponseType = '0';  
    }
    // Retorno de respuesta
    return ResponseType;
}



//**************************************************************************
//                            INTERRUPCIONES
//**************************************************************************


//************************ INTERRUPCIÓN UART1 Rx
void UARTIntHandler1(void) {

    // Declaración de variables
    uint32_t      ui32Status;
    unsigned char GetElement;

    // Set Flag, indicador que hubo una ISR de UART Rx
    Flag = 1;  
    // Tomar el status de la interrupción.
    ui32Status = ROM_UARTIntStatus(UART1_BASE, true);
    // Limpiar interrupción del UART1
    ROM_UARTIntClear(UART1_BASE, ui32Status);

    // Loop para consumir los datos en el FIFO Receive.
    while(ROM_UARTCharsAvail(UART1_BASE)){

        // Consumir datos del FIFO receive y almacenarlos en << FIFO Consumer >>
        GetElement = ROM_UARTCharGetNonBlocking(UART1_BASE);
        PutFifo(GetElement);

        // Toggle Led PN0 para corroborar que se entró a la ISR
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);
        SysCtlDelay(SysCtlClockGet() / (1000 * 3));
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0);
    }
}

//************************ INTERRUPCIÓN UART2 Rx
void UARTIntHandler2(void) {

    uint32_t ui32Status;
    unsigned char GetElement;

    Flag = 1;  // Set Flag, indicador que hubo una ISR de UART Rx

    // Tomar el status de la interrupción.
    ui32Status = ROM_UARTIntStatus(UART2_BASE, true);

    // Limpiar interrupción del UART1
    ROM_UARTIntClear(UART2_BASE, ui32Status);

    // Loop para consumir los datos en el FIFO Receive.
    while(ROM_UARTCharsAvail(UART2_BASE))
    {
        // Consumir datos del FIFO receive y almacenarlos en << FIFO Consumer >>
        GetElement = ROM_UARTCharGetNonBlocking(UART2_BASE);
        PutFifo(GetElement);

        // Toggle Led PN0
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);
        SysCtlDelay(SysCtlClockGet() / (1000 * 3));
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0);
    }
}

//************************ INTERRUPCIÓN UART3 Rx
void UARTIntHandler3(void) {

    uint32_t ui32Status;
    unsigned char GetElement;

    Flag = 1;  // Set Flag, indicador que hubo una ISR de UART Rx

    // Tomar el status de la interrupción.
    ui32Status = ROM_UARTIntStatus(UART3_BASE, true);

    // Limpiar interrupción del UART1
    ROM_UARTIntClear(UART3_BASE, ui32Status);

    // Loop para consumir los datos en el FIFO Receive.
    while(ROM_UARTCharsAvail(UART3_BASE))
    {
        // Consumir datos del FIFO receive y almacenarlos en << FIFO Consumer >>
        GetElement = ROM_UARTCharGetNonBlocking(UART3_BASE);
        PutFifo(GetElement);

        // Toggle Led PN0
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);
        SysCtlDelay(SysCtlClockGet() / (1000 * 3));
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0);
    }
}

//************************ INTERRUPCIÓN UART4 Rx
void UARTIntHandler4(void) {

    uint32_t ui32Status;
    unsigned char GetElement;

    Flag = 1;  // Set Flag, indicador que hubo una ISR de UART Rx

    // Tomar el status de la interrupción.
    ui32Status = ROM_UARTIntStatus(UART4_BASE, true);

    // Limpiar interrupción del UART4
    ROM_UARTIntClear(UART4_BASE, ui32Status);

    // Loop para consumir los datos en el FIFO Receive.
    while(ROM_UARTCharsAvail(UART4_BASE))
    {

        // Consumir datos del FIFO receive y almacenarlos en << FIFO Consumer >>
        GetElement = ROM_UARTCharGetNonBlocking(UART4_BASE);
        PutFifo(GetElement);

        // Toggle Led PN0
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);
        SysCtlDelay(SysCtlClockGet() / (1000 * 3));
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0);
    }

}

//************************ INTERRUPCIÓN UART5 Rx
void UARTIntHandler5(void) {

    uint32_t ui32Status;
    unsigned char GetElement;

    Flag = 1;  // Set Flag, indicador que hubo una ISR de UART Rx

    // Tomar el status de la interrupción.
    ui32Status = ROM_UARTIntStatus(UART5_BASE, true);

    // Limpiar interrupción del UART5
    ROM_UARTIntClear(UART5_BASE, ui32Status);

    // Loop para consumir los datos en el FIFO Receive.
    while(ROM_UARTCharsAvail(UART5_BASE))
    {
        // Consumir datos del FIFO receive y almacenarlos en << FIFO Consumer >>
        GetElement = ROM_UARTCharGetNonBlocking(UART5_BASE);
        PutFifo(GetElement);

        // Toggle Led PN0
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);
        SysCtlDelay(SysCtlClockGet() / (1000 * 3));
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0);
    }
}

//************************ INTERRUPCIÓN UART6 Rx
void UARTIntHandler6(void) {

    uint32_t ui32Status;
    unsigned char GetElement;

    Flag = 1;  // Set Flag, indicador que hubo una ISR de UART Rx

    // Tomar el status de la interrupción.
    ui32Status = ROM_UARTIntStatus(UART6_BASE, true);

    // Limpiar interrupción del UART6
    ROM_UARTIntClear(UART6_BASE, ui32Status);

    // Loop para consumir los datos en el FIFO Receive.
    while(ROM_UARTCharsAvail(UART6_BASE))
    {
        // Consumir datos del FIFO receive y almacenarlos en << FIFO Consumer >>
        GetElement = ROM_UARTCharGetNonBlocking(UART6_BASE);
        PutFifo(GetElement);

        // Toggle Led PN0
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);
        SysCtlDelay(SysCtlClockGet() / (1000 * 3));
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0);
    }
}

//************************ INTERRUPCIÓN UART7 Rx
void UARTIntHandler7(void) {

    uint32_t ui32Status;
    unsigned char GetElement;

    Flag = 1;  // Set Flag, indicador que hubo una ISR de UART Rx

    // Tomar el status de la interrupción.
    ui32Status = ROM_UARTIntStatus(UART7_BASE, true);

    // Limpiar interrupción del UART7
    ROM_UARTIntClear(UART7_BASE, ui32Status);

    // Loop para consumir los datos en el FIFO Receive.
    while(ROM_UARTCharsAvail(UART7_BASE))
    {
        // Consumir datos del FIFO receive y almacenarlos en << FIFO Consumer >>
        GetElement = ROM_UARTCharGetNonBlocking(UART7_BASE);
        PutFifo(GetElement);

        // Toggle Led PN0
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, GPIO_PIN_0);
        SysCtlDelay(SysCtlClockGet() / (1000 * 3));
        GPIOPinWrite(GPIO_PORTN_BASE, GPIO_PIN_0, 0);
    }
}



#include "io_fsdata.h"

//**************************************************************************
//                            URL/Manejadores
//**************************************************************************
//*****************************************************************************
//
// Open a file and return a handle to the file, if found.  Otherwise,
// return NULL.  This function also looks for special file names used to
// provide specific status information or to control various subsystems.
// These file names are used by the JavaScript on the "IO Control Demo 1"
// example web page.
//
//*****************************************************************************
struct fs_file *
fs_open(const char *pcName)
{
    const struct fsdata_file *psTree;
    struct fs_file *psFile = NULL;

//  SysCtlPeripheralReset(SYSCTL_PERIPH_UART4);
//  while(SysCtlPeripheralReady(SYSCTL_PERIPH_UART4) == false);

    //
    // Allocate memory for the file system structure.
    //
    psFile = mem_malloc(sizeof(struct fs_file));
    if(psFile == NULL)
    {
        return(NULL);
    }


if(ustrncmp(pcName, "/puerto1?", 8) == 0){
    
  // Habilitamos interrupción de UART Rx
  UARTIntEnable(UART1_BASE, UART_INT_RX | UART_INT_RT); 
  // Deshabilitamos WatchDog, para evitar reset en este contexto
  WatchdogResetDisable(WATCHDOG0_BASE);

  // Declaración de variables
  unsigned long baudRate;
  static char TypeResponse[2];
  uint32_t ui32Loop, i, j;

  // Obtenemos el baudrate de los parámetros de la URL, llamando a función getParamURL()
  baudRate = getParamURL((char*) pcName + 12);

  // Configuración de UART1: 8 bits de datos, no paridad, 1 bit de stop y 1 bit de start, baudrate
  UARTConfigSetExpClk(UART1_BASE,  g_ui32SysClock, baudRate,
          (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
           UART_CONFIG_PAR_NONE));

  Flag = 0;      // Bandera usada para sincronización de hilos (Foreground-Thread y Background-Thread)
  initFifo();    // Inicializamos FIFO usado para sincronización de hilos

  // Limpiar FIFO Receive para quitar basura y tenerlo listo para tomar datos del FIFO Rx SOLO en el contexto de ISR
  while(ROM_UARTCharsAvail(UART1_BASE))
      j = ROM_UARTCharGetNonBlocking(UART1_BASE);

  // Envío de comandos de control al proyector, tomados de la URL
  for(i=0; i<numberCmd; i++)
      UARTCharPut(UART1_BASE, onCmdHex[i]);

  // Loop (Delay) para esperar a que ocurra la interrupción de UART Rx (Respuesta de proyector)
  for(ui32Loop = 0; ui32Loop < delayToWaitResopnseProj; ui32Loop++){ // 1x10^9 = 100 ms
      if (Flag == 1)
          break;
  }

  Flag = 0;  // Limpear Flag para poesteriores entradas a UART Rx y sincronizar hilos
  TypeResponse[0] = checkProjectorResponse();  // Capturar el tipo de respuesta del proyector 

  // Imprimir tipo de respuesta (por UART0 Tx) del proyector al comandos enviado (NOTA: solo para fines de prueba)
  if (TypeResponse[0] == '0')
      // Error: los comandos de respuesta de proyector no corresponden con los comandos dados por el usuario
      UARTCharPut(UART0_BASE,0X50); 
  else if (TypeResponse[0] == '1')
      // Success: El comando fue correctamente envíado y ejecutado por el proyector (On or Off)
      UARTCharPut(UART0_BASE,0X51); 
  else if (TypeResponse[0] == '2')
      //Error: No hay coexión entre Proyector-uC ó el proyector no respondió al comando enviado
      UARTCharPut(UART0_BASE,0X52); 
  else
     // No Error, No Success ??
      UARTCharPut(UART0_BASE,0X55); 

  // Retorno de respuesta al cliente (Servidor Maestro), del estado de la operación
  psFile->data = TypeResponse;
  psFile->len = strlen(TypeResponse);
  psFile->index = psFile->len;
  psFile->pextension = NULL;

  // Deshabilitamos interrupción para que solo se utilice
  // en el contexto de Envío de Comandos y Respuesta del Proyector
  // y evitar entradas no deseadas por otros contextos
  UARTIntDisable(UART1_BASE, UART_INT_RX);
  WatchdogResetEnable(WATCHDOG0_BASE);
  return(psFile);
}

    else if(ustrncmp(pcName, "/puerto2?", 8) == 0)
    {
        // Habilitamos interrupción
          UARTIntEnable(UART2_BASE, UART_INT_RX| UART_INT_RT);
          WatchdogResetDisable(WATCHDOG0_BASE);

          unsigned long baudRate;
          int i;

          static char TypeResponse[2];

          uint32_t ui32Loop, j;

          baudRate = getParamURL((char*) pcName + 12);

          UARTConfigSetExpClk(UART2_BASE,  g_ui32SysClock, baudRate,
                  (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                   UART_CONFIG_PAR_NONE));

          Flag = 0;            // Bandera usada para sincronización de Foreground-Thread y Background-Thread
          initFifo();          // Inicializamos FIFO usado para sincronización de Foreground-Thread y Background-Thread

          // Limpiar FIFO Receive para quitar basura y tenerlo listo para tomar datos del FIFO Rx SOLO en el contexto de ISR
          while(ROM_UARTCharsAvail(UART2_BASE))
              j = ROM_UARTCharGetNonBlocking(UART2_BASE);

          for(i=0; i<numberCmd; i++){
              UARTCharPut(UART2_BASE, onCmdHex[i]);
          }

          // Loop (Delay) para esperar a que ocurra la interrupción de UART Rx
          for(ui32Loop = 0; ui32Loop < delayToWaitResopnseProj; ui32Loop++){ //1000000
              if (Flag == 1)
                  break;
          }

          Flag = 0;  // Limpear Flag para poesteriores entradas a UART Rx y sincronizar hilos
          TypeResponse[0] = checkProjectorResponse();  // Capturar el tipo de respuesta del proyector Success R, Fail R, Error-Conexion

          // Prueba para ver el tipo de respuesta
          if (TypeResponse[0] == '0')
              UARTCharPut(UART0_BASE,0X50); //Error: los comandos de respuesta de proyector no corresponden con los comandos dados por el usuario
          else if (TypeResponse[0] == '1')
              UARTCharPut(UART0_BASE,0X51); //Success: El comando fue correctamente envíado y ejecutado por el proyector
          else if (TypeResponse[0] == '2')
              UARTCharPut(UART0_BASE,0X52); //Error: No hay coexión entre el Proyector-uC ó el proyector no respondió al comando enviado
          else
              UARTCharPut(UART0_BASE,0X55); //No Error, No Success ??

          psFile->data = TypeResponse;
          psFile->len = strlen(TypeResponse);
          psFile->index = psFile->len;
          psFile->pextension = NULL;

          // Deshabilitamos interrupción para que solo se utilice
          // en el contexto de Envío de Comandos y Respuesta del Proyector
          // y evitar entradas no deseadas por otros contextos
          UARTIntDisable(UART2_BASE, UART_INT_RX);
          WatchdogResetEnable(WATCHDOG0_BASE);
          return(psFile);
    }


    if(ustrncmp(pcName, "/puerto3?", 8) == 0)
    {
        // Habilitamos interrupción
          UARTIntEnable(UART3_BASE, UART_INT_RX | UART_INT_RT);
          WatchdogResetDisable(WATCHDOG0_BASE);

          unsigned long baudRate;
          int i;

          static char TypeResponse[2];

          uint32_t ui32Loop, j;

          baudRate = getParamURL((char*) pcName + 12);

          UARTConfigSetExpClk(UART3_BASE,  g_ui32SysClock, baudRate,
                  (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                   UART_CONFIG_PAR_NONE));

          Flag = 0;            // Bandera usada para sincronización de Foreground-Thread y Background-Thread
          initFifo();          // Inicializamos FIFO usado para sincronización de Foreground-Thread y Background-Thread

          // Limpiar FIFO Receive para quitar basura y tenerlo listo para tomar datos del FIFO Rx SOLO en el contexto de ISR
          while(ROM_UARTCharsAvail(UART3_BASE))
              j = ROM_UARTCharGetNonBlocking(UART3_BASE);

          for(i=0; i<numberCmd; i++){
              UARTCharPut(UART3_BASE, onCmdHex[i]);
          }

          // Loop (Delay) para esperar a que ocurra la interrupción de UART Rx
          for(ui32Loop = 0; ui32Loop < delayToWaitResopnseProj; ui32Loop++){ //1000000
              if (Flag == 1)
                  break;
          }

          Flag = 0;  // Limpear Flag para poesteriores entradas a UART Rx y sincronizar hilos
          TypeResponse[0] = checkProjectorResponse();  // Capturar el tipo de respuesta del proyector Success R, Fail R, Error-Conexion

          // Prueba para ver el tipo de respuesta
          if (TypeResponse[0] == '0')
              UARTCharPut(UART0_BASE,0X50); //Error: los comandos de respuesta de proyector no corresponden con los comandos dados por el usuario
          else if (TypeResponse[0] == '1')
              UARTCharPut(UART0_BASE,0X51); //Success: El comando fue correctamente envíado y ejecutado por el proyector
          else if (TypeResponse[0] == '2')
              UARTCharPut(UART0_BASE,0X52); //Error: No hay coexión entre el Proyector-uC ó el proyector no respondió al comando enviado
          else
              UARTCharPut(UART0_BASE,0X55); //No Error, No Success ??

          psFile->data = TypeResponse;
          psFile->len = strlen(TypeResponse);
          psFile->index = psFile->len;
          psFile->pextension = NULL;

          // Deshabilitamos interrupción para que solo se utilice
          // en el contexto de Envío de Comandos y Respuesta del Proyector
          // y evitar entradas no deseadas por otros contextos
          UARTIntDisable(UART3_BASE, UART_INT_RX);
          WatchdogResetEnable(WATCHDOG0_BASE);
          return(psFile);
    }



    else if(ustrncmp(pcName, "/puerto4?", 8) == 0)
    {
        // Habilitamos interrupción
        UARTIntEnable(UART4_BASE, UART_INT_RX | UART_INT_RT);
        WatchdogResetDisable(WATCHDOG0_BASE);

        unsigned long baudRate;
        int i;

        static char TypeResponse[2];

        uint32_t ui32Loop, j;

        baudRate = getParamURL((char*) pcName + 12);

        UARTConfigSetExpClk(UART4_BASE,  g_ui32SysClock, baudRate,
                (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                 UART_CONFIG_PAR_NONE));

        Flag = 0;            // Bandera usada para sincronización de Foreground-Thread y Background-Thread
        initFifo();          // Inicializamos FIFO usado para sincronización de Foreground-Thread y Background-Thread

        // Limpear FIFO Receive para quitar basura y tenerlo listo para tomar datos del FIFO Rx SOLO en el contexto de ISR
        while(ROM_UARTCharsAvail(UART4_BASE))
            j = ROM_UARTCharGetNonBlocking(UART4_BASE);

        for(i=0; i<numberCmd; i++){
            UARTCharPut(UART4_BASE, onCmdHex[i]);
        }

        // Loop (Delay) para esperar a que ocurra la interrupción de UART Rx
        for(ui32Loop = 0; ui32Loop < delayToWaitResopnseProj; ui32Loop++){ //1000000
            if (Flag == 1)
                break;
        }

        Flag = 0;  // Limpear Flag para poesteriores entradas a UART Rx y sincronizar hilos
        TypeResponse[0] = checkProjectorResponse();  // Capturar el tipo de respuesta del proyector Success R, Fail R, Error-Conexion


        // Prueba para ver el tipo de respuesta
        if (TypeResponse[0] == '0')
            UARTCharPut(UART0_BASE,0X50); //Error: los comandos de respuesta de proyector no corresponden con los comandos dados por el usuario
        else if (TypeResponse[0] == '1')
            UARTCharPut(UART0_BASE,0X51); //Success: El comando fue correctamente envíado y ejecutado por el proyector
        else if (TypeResponse[0] == '2')
            UARTCharPut(UART0_BASE,0X52); //Error: No hay coexión entre el Proyector-uC ó el proyector no respondió al comando enviado
        else
            UARTCharPut(UART0_BASE,0X55); //No Error, No Success ??

        psFile->data = TypeResponse;
        psFile->len = strlen(TypeResponse);
        psFile->index = psFile->len;
        psFile->pextension = NULL;

        // Deshabilitamos interrupción para que solo se utilice
        // en el contexto de Envío de Comandos y Respuesta del Proyector
        // y evitar entradas no deseadas por otros contextos
        UARTIntDisable(UART4_BASE, UART_INT_RX);
        WatchdogResetEnable(WATCHDOG0_BASE);
        return(psFile);
    }

    else if(ustrncmp(pcName, "/puerto5?", 8) == 0)
    {
        // Habilitamos interrupción
        UARTIntEnable(UART5_BASE, UART_INT_RX | UART_INT_RT);
        WatchdogResetDisable(WATCHDOG0_BASE);

        unsigned long baudRate;
        int i;

        static char TypeResponse[2];

        uint32_t ui32Loop, j;

        baudRate = getParamURL((char*) pcName + 12);

        UARTConfigSetExpClk(UART5_BASE,  g_ui32SysClock, baudRate,
                (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                 UART_CONFIG_PAR_NONE));

        Flag = 0;            // Bandera usada para sincronización de Foreground-Thread y Background-Thread
        initFifo();          // Inicializamos FIFO usado para sincronización de Foreground-Thread y Background-Thread

        // Limpear FIFO Receive para quitar basura y tenerlo listo para tomar datos del FIFO Rx SOLO en el contexto de ISR
        while(ROM_UARTCharsAvail(UART5_BASE))
            j = ROM_UARTCharGetNonBlocking(UART5_BASE);

        for(i=0; i<numberCmd; i++){
            UARTCharPut(UART5_BASE, onCmdHex[i]);
        }

        // Loop (Delay) para esperar a que ocurra la interrupción de UART Rx
        for(ui32Loop = 0; ui32Loop < delayToWaitResopnseProj; ui32Loop++){ //1000000
            if (Flag == 1)
                break;
        }

        Flag = 0;  // Limpear Flag para poesteriores entradas a UART Rx y sincronizar hilos
        TypeResponse[0] = checkProjectorResponse();  // Capturar el tipo de respuesta del proyector Success R, Fail R, Error-Conexion


        // Prueba para ver el tipo de respuesta
        if (TypeResponse[0] == '0')
            UARTCharPut(UART0_BASE,0X50); //Error: los comandos de respuesta de proyector no corresponden con los comandos dados por el usuario
        else if (TypeResponse[0] == '1')
            UARTCharPut(UART0_BASE,0X51); //Success: El comando fue correctamente envíado y ejecutado por el proyector
        else if (TypeResponse[0] == '2')
            UARTCharPut(UART0_BASE,0X52); //Error: No hay coexión entre el Proyector-uC ó el proyector no respondió al comando enviado
        else
            UARTCharPut(UART0_BASE,0X55); //No Error, No Success ??

        psFile->data = TypeResponse;
        psFile->len = strlen(TypeResponse);
        psFile->index = psFile->len;
        psFile->pextension = NULL;

        // Deshabilitamos interrupción para que solo se utilice
        // en el contexto de Envío de Comandos y Respuesta del Proyector
        // y evitar entradas no deseadas por otros contextos
        UARTIntDisable(UART5_BASE, UART_INT_RX);
        WatchdogResetEnable(WATCHDOG0_BASE);
        return(psFile);
    }

    else if(ustrncmp(pcName, "/puerto6?", 8) == 0)
    {
        // Habilitamos interrupción
        UARTIntEnable(UART6_BASE, UART_INT_RX | UART_INT_RT);
        WatchdogResetDisable(WATCHDOG0_BASE);

        unsigned long baudRate;
        int i;

        static char TypeResponse[2];

        uint32_t ui32Loop, j;

        baudRate = getParamURL((char*) pcName + 12);

        UARTConfigSetExpClk(UART6_BASE,  g_ui32SysClock, baudRate,
                (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                 UART_CONFIG_PAR_NONE));

        Flag = 0;            // Bandera usada para sincronización de Foreground-Thread y Background-Thread
        initFifo();          // Inicializamos FIFO usado para sincronización de Foreground-Thread y Background-Thread

        // Limpear FIFO Receive para quitar basura y tenerlo listo para tomar datos del FIFO Rx SOLO en el contexto de ISR
        while(ROM_UARTCharsAvail(UART6_BASE))
            j = ROM_UARTCharGetNonBlocking(UART6_BASE);

        for(i=0; i<numberCmd; i++){
            UARTCharPut(UART6_BASE, onCmdHex[i]);
        }

        // Loop (Delay) para esperar a que ocurra la interrupción de UART Rx
        for(ui32Loop = 0; ui32Loop < delayToWaitResopnseProj; ui32Loop++){ //1000000
            if (Flag == 1)
                break;
        }

        Flag = 0;  // Limpear Flag para poesteriores entradas a UART Rx y sincronizar hilos
        TypeResponse[0] = checkProjectorResponse();  // Capturar el tipo de respuesta del proyector Success R, Fail R, Error-Conexion

        // Prueba para ver el tipo de respuesta
        if (TypeResponse[0] == '0')
            UARTCharPut(UART0_BASE,0X50); //Error: los comandos de respuesta de proyector no corresponden con los comandos dados por el usuario
        else if (TypeResponse[0] == '1')
            UARTCharPut(UART0_BASE,0X51); //Success: El comando fue correctamente envíado y ejecutado por el proyector
        else if (TypeResponse[0] == '2')
            UARTCharPut(UART0_BASE,0X52); //Error: No hay coexión entre el Proyector-uC ó el proyector no respondió al comando enviado
        else
            UARTCharPut(UART0_BASE,0X55); //No Error, No Success ??

        psFile->data = TypeResponse;
        psFile->len = strlen(TypeResponse);
        psFile->index = psFile->len;
        psFile->pextension = NULL;

        // Deshabilitamos interrupción para que solo se utilice
        // en el contexto de Envío de Comandos y Respuesta del Proyector
        // y evitar entradas no deseadas por otros contextos
        UARTIntDisable(UART6_BASE, UART_INT_RX);
        WatchdogResetEnable(WATCHDOG0_BASE);
        return(psFile);
    }

    else if(ustrncmp(pcName, "/puerto7?", 8) == 0)
    {
        // Habilitamos interrupción
        UARTIntEnable(UART7_BASE, UART_INT_RX | UART_INT_RT);
        WatchdogResetDisable(WATCHDOG0_BASE);

        unsigned long baudRate;
        int i;

        static char TypeResponse[2];

        uint32_t ui32Loop, j;

        baudRate = getParamURL((char*) pcName + 12);

        UARTConfigSetExpClk(UART7_BASE,  g_ui32SysClock, baudRate,
                (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE |
                 UART_CONFIG_PAR_NONE));

        Flag = 0;            // Bandera usada para sincronización de Foreground-Thread y Background-Thread
        initFifo();          // Inicializamos FIFO usado para sincronización de Foreground-Thread y Background-Thread

        // Limpear FIFO Receive para quitar basura y tenerlo listo para tomar datos del FIFO Rx SOLO en el contexto de ISR
        while(ROM_UARTCharsAvail(UART7_BASE))
            j = ROM_UARTCharGetNonBlocking(UART7_BASE);

        for(i=0; i<numberCmd; i++){
            UARTCharPut(UART7_BASE, onCmdHex[i]);
        }

        // Loop (Delay) para esperar a que ocurra la interrupción de UART Rx
        for(ui32Loop = 0; ui32Loop < delayToWaitResopnseProj; ui32Loop++){ //1000000
            if (Flag == 1)
                break;
        }

        Flag = 0;  // Limpear Flag para poesteriores entradas a UART Rx y sincronizar hilos
        TypeResponse[0] = checkProjectorResponse();  // Capturar el tipo de respuesta del proyector Success R, Fail R, Error-Conexion

        // Prueba para ver el tipo de respuesta
        if (TypeResponse[0] == '0')
            UARTCharPut(UART0_BASE,0X50); //Error: los comandos de respuesta de proyector no corresponden con los comandos dados por el usuario
        else if (TypeResponse[0] == '1')
            UARTCharPut(UART0_BASE,0X51); //Success: El comando fue correctamente envíado y ejecutado por el proyector
        else if (TypeResponse[0] == '2')
            UARTCharPut(UART0_BASE,0X52); //Error: No hay coexión entre el Proyector-uC ó el proyector no respondió al comando enviado
        else
            UARTCharPut(UART0_BASE,0X55); //No Error, No Success ??

        psFile->data = TypeResponse;
        psFile->len = strlen(TypeResponse);
        psFile->index = psFile->len;
        psFile->pextension = NULL;

        // Deshabilitamos interrupción para que solo se utilice
        // en el contexto de Envío de Comandos y Respuesta del Proyector
        // y evitar entradas no deseadas por otros contextos
        UARTIntDisable(UART7_BASE, UART_INT_RX);
        WatchdogResetEnable(WATCHDOG0_BASE);
        return(psFile);
    }

    // If I can't find it there, look in the rest of the main psFile system
    //
    else
    {
        //
        // Initialize the psFile system tree pointer to the root of the linked
        // list.
        //
        psTree = FS_ROOT;

        //
        // Begin processing the linked list, looking for the requested file name.
        //
        while(NULL != psTree)
        {
            //
            // Compare the requested file "pcName" to the file name in the
            // current node.
            //
            if(ustrncmp(pcName, (char *)psTree->name, psTree->len) == 0)
            {
                //
                // Fill in the data pointer and length values from the
                // linked list node.
                //
                psFile->data = (char *)psTree->data;
                psFile->len = psTree->len;

                //
                // For now, we setup the read index to the end of the file,
                // indicating that all data has been read.
                //
                psFile->index = psTree->len;

                //
                // We are not using any file system extensions in this
                // application, so set the pointer to NULL.
                //
                psFile->pextension = NULL;

                //
                // Exit the loop and return the file system pointer.
                //
                break;
            }

            //
            // If we get here, we did not find the file at this node of the
            // linked list.  Get the next element in the list.
            //
            psTree = psTree->next;
        }
    }

    //
    // If we didn't find the file, ptTee will be NULL.  Make sure we
    // return a NULL pointer if this happens.
    //
    if(NULL == psTree)
    {
        mem_free(psFile);
        psFile = NULL;
    }

    //
    // Return the file system pointer.
    //
    return(psFile);
}

//*****************************************************************************
//
// Close an opened file designated by the handle.
//
//*****************************************************************************
void
fs_close(struct fs_file *psFile)
{
    //
    // Free the main psFile system object.
    //
    mem_free(psFile);
}

//*****************************************************************************
//
// Read the next chunk of data from the file.  Return the iCount of data
// that was read.  Return 0 if no data is currently available.  Return
// a -1 if at the end of file.
//
//*****************************************************************************
int
fs_read(struct fs_file *psFile, char *pcBuffer, int iCount)
{
    int iAvailable;

    //
    // Check to see if a command (pextension = 1).
    //
    if(psFile->pextension == (void *)1)
    {
        //
        // Nothing to do for this file type.
        //
        psFile->pextension = NULL;
        return(-1);
    }

    //
    // Check to see if more data is available.
    //
    if(psFile->len == psFile->index)
    {
        //
        // There is no remaining data.  Return a -1 for EOF indication.
        //
        return(-1);
    }

    //
    // Determine how much data we can copy.  The minimum of the 'iCount'
    // parameter or the available data in the file system buffer.
    //
    iAvailable = psFile->len - psFile->index;
    if(iAvailable > iCount)
    {
        iAvailable = iCount;
    }

    //
    // Copy the data.
    //
    memcpy(pcBuffer, psFile->data + iAvailable, iAvailable);
    psFile->index += iAvailable;

    //
    // Return the count of data that we copied.
    //
    return(iAvailable);
}

//*****************************************************************************
//
// Determine the number of bytes left to read from the file.
//
//*****************************************************************************
int
fs_bytes_left(struct fs_file *psFile)
{
    //
    // Return the number of bytes left to be read from this file.
    //
    return(psFile->len - psFile->index);
}
